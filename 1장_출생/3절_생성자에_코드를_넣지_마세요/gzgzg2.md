# 📌 1.3 생성자에 코드를 넣지 마세요

## 정리

### 1. 생성자는 프로퍼티를 초기화를 목적으로 생성해야 한다

- 주 생성자는 객체 초기화 프로세스를 시작하는 유일한 장소이기 때문에 제공되는 인자들은 완전해야 한다.
- 주 생성자의 인자는 건드려서는 안된다. 필요하다면 인자를 직접 가공하는게 아닌 다른 타입으로 감싸거나 가공하지 않은 형식(raw form)으로 캡슐화 해야한다.
- 캡슐화하고 나중에 요청이 있을 때(on demand) 파싱하도록 하면, 클래스의 사용자들이 파싱 시점을 자유롭게 결정할 수 있다.
- 객체를 인스턴스화 하는 것과 객체가 할 일을 정의하는 것은 따로 이뤄져야 한다. 두 작업이 겹쳐서는 안된다.

<br>

**✔️ 예시**

```java
class Cash { // 나쁜 예
	private int dollars;
	
	Cash(String dir) {
		this.dollars = Integer.parseInt(dir);	
	}

	Cash(int dir) {
		this.dollars = dir;	
	}
}

class Cash { // 좋은 예
	private Number dollars;

	Cash(String dir) {
		this(new StringAsInteger(dir)); 
	}

	Cash(Number dir) {
		this.dollars = dir;
	}
}

class StringAsInteger extends Number {
	private String source;

	StringAsInteger(String src) {
		this.source = src;
	}

	int intValue() {
		return Integer.parseInt(this.source);
	}
}
```

나쁜 예시와 좋은 예시의 핵심은 **‘객체의 변환 작업을 언제 진행하는 것인가?’** 이다. 나쁜 예시의 코드는 객체를 초기화 하는 시점에 바로 텍스트로 변환하고, 좋은 예시의 코드는 실제로 사용하는 시점까지 객체의 변환 작업을 연기한다.  

<br>


**✔️ 요약** 

- 객체를 생성할 때마다 인자의 변환 작업을 수행하면 변환 작업의 실행 여부를 제어하기 어렵다.
- 변환 할 필요가 없는 경우에도  매번 호출되기 때문에 불필요한 CPU 작업을 하게 된다.
- 생성자에서 어떠한 작업을 처리하게 되면 리팩토링을 수행하는 프로그래머는 ctor 내부의 처리 로직을 메소드로 옮기고 나서야 코드를 실제로 변경할 수 있게 된다.
- 가벼운 ctor은 설정이 쉽고 투명하게 객체를 더 빠르게 만들 수 있다.

```text
진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서(compose) 더 큰 객체를 만드는 것이다.
객체를 조합하는 단하나의 이유는 새로운 계약을 준수하는 새로운 엔티티가 필요하기 때문이다.
```

<br>


## 느낀점

생성자에서 직접 인자를 변환했던 경우가 꽤 있다. 최근에도 Object 타입으로 인자를 받고 인자를 Json 포맷의 StringValue로 변환하는 코드를 작성했었다. 이 장을 읽고 코드를 다시 보니 .. 해당 객체의 용도를 전혀 모르는 상태에서 사용했을 때  사용자가 원하지 않는 결과를 반환할 수 있겠다는 생각이 들었다. 

그런데 아직 감이 오지 않는다. 어떻게 해야 좋은 설계일지. 그리고 다른 타입으로 감싸거나 미가공 형태(raw form)으로 캡슐화 하라고 하는데,  미가공 형태로 캡슐화 하라는 것이 원시값을 캡슐화 하라는 것인가..? 잘 이해가 되지 않는다.
