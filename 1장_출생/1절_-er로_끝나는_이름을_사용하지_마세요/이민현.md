새로 만들어질 **객체의 가시성 범위를 이해하고 난 후에 가장 먼저 할일은 클래스에 적합한 이름을 짓는것**이다.

# 클래스는 객체의 팩토리이다.

클래스는 객체를 인스턴스화 한다.

- 클래스는 객체의 팩토리이며, 객체를 생성한다고 표현한다.

`new` 연산자와 팩토리 패턴은 개념적으로 동일하다.

- `new` 는 클래스의 정적메서드와 같은데, 팩토리 패턴은 `new` 연산자를 대신하여 사용할 수 있는 더 강력한 옵션이다.

클래스를 필요할 때 객체를 꺼낼 수 있고, 필요하지 않은 객체를 반환할 수 있는 객체의 웨어하우스로 바라보자.

클래스는 객체의 템플릿이 아니다.

- 클래스를 객체의 능동적인 관리자로 생각하자.
- 클래스는 객체를 꺼내거나 반환할 수 있기 때문에 ‘저장소' 혹은 ‘웨어하우스'라고 불러야 한다.

# 클래스 이름을 짓는 잘못된 방법과 적절한 방법

**클래스의 이름은 무엇을 하는지(what he does)가 아니라 무엇인지(what he is)에 기반해야 한다.**

## 잘못된 방법

- 객체들이 무엇을 하고 있는(doing)지를 살핀 후 기능(functionality)에 기반하여 이름을 짓는 것.
    - (ex) ~Formatter → 숫자를 문자로 포맷팅 하는 일 등

## 적절한 방법

- 객체는 역량(capability)로 특징 지어져야 한다.
    - 키, 몸무게, 피부색과 같은 속성(attribute)가 아닌 할 수 있는 일(what I can do)로 설명 되어야한다.

좌측은 잘못된 방법, 우측은 적절한 방법.

- CashFormatter → Cash, USDCash, CashInUSD
- format() → usd()
- PrimeFinder, PrimeHelper → PrimeNumbers

# 객체는 연결 장치가 아니라 대표자여야 한다.

‘연결장치'는 스스로 수행할 수 없기 때문에 단순히 정보를 전달하기만 한다. 반면 대표자는 스스로 결정을 내리고 행동할 수 있다.

클래스의 이름이 ‘-er’로 끝난다면 이 인스턴스는 실제로 객체가 아니라 데이터를 다루는 절차들의 집합일 뿐이다.

외부에서 어떤 일을 해야 한다면 객체에게 그 일을 하도록 요청하고, 수신한 요청을 객체 스스로 무엇을 할지 결정해야 한다.

# 요약

새로운 클래스에 이름을 붙일 때는 무엇을 하는지(what he does)가 아니라 무엇인지(what he is)를 생각해야 한다.

---

# 느낀점

방금 전까지 ‘~Converter’, ‘~Parser’ 라는 클래스를 만들고 왔는데, 첫장부터 뼈맞았다.

인터페이스로 빼면서 여러 구현체를 만들다보니 어쩔수 없이 만들게 되었다. 솔직히 만들면서 해당 로직은 도메인 클래스 안에서 메서드로써 있어야하지 않을까 생각하긴 했지만 정말 이분법적으로 그게 무조건 맞는걸까?

사실 Validator, Formatter, Converter등의 네이밍을 정말 싫어한다. 그중에서도 Validator를 만드는것을 본인은 굉장히 지양하고 있지만 첫삽부터 설계가 잘 된 서비스라면 문제없지만 레거시라면 어쩔수 없이 사용할 수 밖에 없는 현실이라.. 저자가 강력하게 주장하는 바 이해는 되나 조금 아쉽기도 하다.

그리고 `NEXTSTEP`이나, `객체지향의 사실과 오해` 책에서도 그렇고 **객체에게 메시지를 보내라** 라는것을 중요하게 얘기하는데 이 책도 마찬가지인듯 하다.