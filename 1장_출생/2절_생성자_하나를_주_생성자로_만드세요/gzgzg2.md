# 📌 1.2 생성자 하나를 주 생성자로 만드세요
## 정리

### 1. 다수의 생성자가 클래스를 견고하고 유연하게 한다.

- 응집도가 높고 견고한 클래스는 많은 수의 생성자와 적은 수의 메소드를 가진다.
- 생성자가 많아질수록 클라이언트가 객체를 유연하게 사용할 수 있다.
- 메서드가 많아질수록 클래스의 책임이 커지고 어려워진다. 책임이 많아진다는 것은 결국 단일 책임 원칙을 위반하게 되는 것이다.
- 결론은 유연한 클래스는 많은 생성자와 적은 메서드를 가지고 있다.

<br>

**예시**

```java
class Cash {
	private int dollars;

	Cash(String dir) {}

	Cash(int dir) {}

	Cash(double dir) {}

	Cash(float dir) {}
}

new Cash(30);
new Cash("$29.95");
new Cash(29.95d);
new Cash(29.95f);
new Cash(29.95, "USD");
```

예시처럼 여러 생성자가 존재할 경우 사용자는 인자의 타입을 변환하거나 파싱하는 작업을 신경쓰지 않아도 된다. 클래스 내부에서 대신 작업을 처리하면 되기 때문이다. 이는 사용자가 인자를 변환하는 코드를 작성하지 않아도 되어 중복 코드가 감소한다는 장점과 객체의 유연성이 증가한다는 장점으로 이어진다.


### 2. 하나의 주 생성자와 다수의 부 생성자를 만들어라.

- 프로퍼티 초기화 로직은 `주 생성자`에만 위치시키고 `부 생성자`가 `주 생성자`를 호출하게 만들어라.
- 다수의 부 생성자가 존재할 때 주 생성자를 제일 마지막에 위치시켜라. 이는 코드를 전부 탐색하여 주 생성자를 찾는 수고를 덜어준다.
- `하나의 주 생성자와 다수의 부 생성자` 원칙의 핵심은 중복코드를 방지하고 간결한 설계와 유지보수성을 향상시키는 것이다.

<br>

**예시**

```java
//안 좋은 방법
class Cash {
	private int dollars;

	Cash(float dir) { // 나쁨
		valid(dir);
		this.dollars = (int) dir;
	}

	Cash(String dir) { // 나쁨
		valid(dir);
		this.dollars = Cash.parse(dir);
	}

	Cash(int dir) {
		valid(dir);
		this.dollars = dir;
	}
}

// 좋은 방법
class Cash {
	private int dollars;

	Cash(float dir) { 
		this((int)dir);
	}

	Cash(String dir) { 
		this(Cash.parse(dir));
	}

	Cash(int dir) {
		valid(dir);		
		this.dollars = dir;
	}
}
```

예제의 안 좋은 방법의 코드는 각 생성자마다 따로 검증로직을 중복으로 호출하고 있다. 반면 좋은 방법의 코드는 부 생성자가 주 생성자를 호출하는 방식으로, 주 생성자 안에서만 검증로직을 추가하면 된다. 이처럼  `하나의 주 생성자와 다수의 부 생성자` 원칙은 중복코드를 줄일 수 있고 설계를 간결하게 한다.

## 느낀점

다수의 생성자를 생성하는 방식은 클라이언트의 책임을 덜어주고 설계를 유연하게 하는 것 같다. 저번 챕터의 내용은 대부분 동의하지만 조금의 반감은 있었는데 이번 내용은 반감이 들지 않는다. 

그리고 `다수의 부 생성자와 하나의 주 생성자` 원칙은 점층적 생성자 패턴의 시초(?)인 거 같다. 점층적 생성자 패턴이 결국 마지막에 도달하는 것이 주 생성자인 것과  해당 원칙이 비슷하다고 느껴졌다.
